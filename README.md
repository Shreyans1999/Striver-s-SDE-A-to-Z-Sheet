# Striver's A2Z DSA Course/Sheet

## Overview
This course provides a comprehensive, free resource for learning Data Structures and Algorithms (DSA) from A to Z in a structured manner. The course quality matches or exceeds paid alternatives, with the only difference being direct doubt support. However, our active YouTube community of 250K+ members provides excellent support through video comments.

## Progress Tracker
- Total Problems: 455
- Current Progress: 0/455 (0% complete)

## Detailed Course Content

### Step 1: Learn the Basics (31)
<details>
<summary>1.1 Things to Know in C++/Java/Python (9)</summary>

1. User Input / Output
2. Data Types
3. If Else statements
4. Switch Statement
5. What are arrays, strings?
6. For loops
7. While loops
8. Functions (Pass by Reference and Value)
9. Time Complexity
</details>

<details>
<summary>1.2 Build-up Logical Thinking (1)</summary>

1. Patterns
</details>

<details>
<summary>1.3 Learn STL/Java Collections (2)</summary>

1. C++ STL
2. Java Collections
</details>

<details>
<summary>1.4 Know Basic Maths (7)</summary>

1. Count Digits
2. Reverse a Number
3. Check Palindrome
4. GCD Or HCF
5. Armstrong Numbers
6. Print all Divisors
7. Check for Prime
</details>

<details>
<summary>1.5 Learn Basic Recursion (9)</summary>

1. Understand recursion by print something N times
2. Print name N times using recursion
3. Print 1 to N using recursion
4. Print N to 1 using recursion
5. Sum of first N numbers
6. Factorial of N numbers
7. Reverse an array
8. Check if a string is palindrome or not
9. Fibonacci Number
</details>

<details>
<summary>1.6 Learn Basic Hashing (3)</summary>

1. Hashing Theory
2. Counting frequencies of array elements
3. Find the highest/lowest frequency element
</details>

### Step 2: Learn Important Sorting Techniques (7)
<details>
<summary>2.1 Sorting-I (3)</summary>

1. Selection Sort
2. Bubble Sort
3. Insertion Sort
</details>

<details>
<summary>2.2 Sorting-II (4)</summary>

1. Merge Sort
2. Recursive Bubble Sort
3. Recursive Insertion Sort
4. Quick Sort
</details>

### Step 3: Solve Problems on Arrays (40)
<details>
<summary>3.1 Easy (14)</summary>

1. Largest Element in an Array
2. Second Largest Element in an Array
3. Check if array is sorted
4. Remove duplicates from Sorted array
5. Left Rotate an array by one place
6. Left rotate an array by D places
7. Move Zeros to end
8. Linear Search
9. Find the Union
10. Find missing number in array
11. Maximum Consecutive Ones
12. Find the number appearing once
13. Longest subarray with given sum K (positives)
14. Longest subarray with sum K (Positives + Negatives)
</details>

<details>
<summary>3.2 Medium (14)</summary>

1. 2Sum Problem
2. Sort an array of 0's 1's and 2's
3. Majority Element (>n/2 times)
4. Kadane's Algorithm
5. Print subarray with maximum sum
6. Stock Buy and Sell
7. Rearrange array elements
8. Next Permutation
9. Leaders in an Array
10. Longest Consecutive Sequence
11. Set Matrix Zeros
12. Rotate Matrix by 90 degrees
13. Print matrix in spiral manner
14. Count subarrays with given sum
</details>

<details>
<summary>3.3 Hard (12)</summary>

1. Pascal's Triangle
2. Majority Element (n/3 times)
3. 3-Sum Problem
4. 4-Sum Problem
5. Largest Subarray with 0 Sum
6. Count subarrays with given XOR
7. Merge Overlapping Subintervals
8. Merge two sorted arrays
9. Find repeating and missing number
10. Count Inversions
11. Reverse Pairs
12. Maximum Product Subarray
</details>

### Step 4: Binary Search (32)
<details>
<summary>4.1 BS on 1D Arrays (13)</summary>

1. Binary Search to find X
2. Implement Lower Bound
3. Implement Upper Bound
4. Search Insert Position
5. Floor/Ceil in Sorted Array
6. First and Last Occurrences
7. Count occurrences in sorted array
8. Search in Rotated Sorted Array I
9. Search in Rotated Sorted Array II
10. Find minimum in Rotated Sorted Array
11. Number of times array is rotated
12. Single element in Sorted Array
13. Find peak element
</details>

<details>
<summary>4.2 BS on Answers (14)</summary>

1. Square Root using Binary Search
2. Find Nth Root
3. Koko Eating Bananas
4. Minimum days to make M bouquets
5. Smallest Divisor
6. Capacity To Ship Packages
7. Kth Missing Positive Number
8. Aggressive Cows
9. Book Allocation Problem
10. Split Array - Largest Sum
11. Painter's Partition
12. Minimize Max Distance to Gas Station
13. Median of 2 sorted arrays
14. Kth element of 2 sorted arrays
</details>

<details>
<summary>4.3 BS on 2D Arrays (5)</summary>

1. Row with maximum number of 1's
2. Search in a 2D matrix
3. Search in row-column sorted matrix
4. Find Peak Element (2D)
5. Matrix Median
</details>

### Step 5: Strings (15)
<details>
<summary>5.1 Basic and Easy String Problems (7)</summary>

1. Remove Outermost Parenthesis
2. Reverse Words/Palindrome Check
3. Largest Odd Number in String
4. Longest Common Prefix
5. Isomorphic Strings
6. Check for Rotation
7. Check for Anagram
</details>

<details>
<summary>5.2 Medium String Problems (8)</summary>

1. Sort Characters by Frequency
2. Maximum Nesting Depth
3. Roman Number Conversions
4. Implement Atoi
5. Count Number of Substrings
6. Longest Palindromic Substring
7. Sum of Beauty of Substrings
8. Reverse Words in String
</details>

### Step 6: Linked List (31)
<details>
<summary>6.1 1D LinkedList (5)</summary>

1. Introduction to LinkedList
2. Inserting a node
3. Deleting a node
4. Find length of LL
5. Search in LL
</details>

<details>
<summary>6.2 Doubly LinkedList (4)</summary>

1. Introduction to DLL
2. Insert in DLL
3. Delete in DLL
4. Reverse DLL
</details>

<details>
<summary>6.3 Medium LL Problems (15)</summary>

1. Middle of LinkedList
2. Reverse LL (Iterative)
3. Reverse LL (Recursive)
4. Detect Loop
5. Find starting point of Loop
6. Length of Loop
7. Check Palindrome
8. Segregate odd and even
9. Remove Nth node from end
10. Delete middle node
11. Sort LL
12. Sort 0s, 1s and 2s
13. Find intersection point
14. Add 1 to LL
15. Add two numbers in LL
</details>

<details>
<summary>6.4 Medium DLL Problems (3)</summary>

1. Delete all occurrences
2. Find pairs with given sum
3. Remove duplicates
</details>

<details>
<summary>6.5 Hard Problems (4)</summary>

1. Reverse LL in groups
2. Rotate LL
3. Flattening of LL
4. Clone LL with random pointer
</details>

### Step 7: Recursion (25)
<details>
<summary>7.1 Get Strong Hold (5)</summary>

1. Recursive Implementation of atoi()
2. Pow(x, n)
3. Count Good numbers
4. Sort a stack
5. Reverse a stack
</details>

<details>
<summary>7.2 Subsequences Pattern (12)</summary>

1. Generate binary strings
2. Generate Parentheses
3. Print all subsequences
4. All Subsequence Patterns
5. Count subsequences with sum K
6. Check subsequence with sum K
7. Combination Sum
8. Combination Sum II
9. Subset Sum I
10. Subset Sum II
11. Combination Sum III
12. Letter Combinations
</details>

<details>
<summary>7.3 Hard Recursion Problems (8)</summary>

1. Palindrome Partitioning
2. Word Search
3. N Queen
4. Rat in a Maze
5. Word Break
6. M Coloring
7. Sudoku Solver
8. Expression Add Operators
</details>

### Step 8: Bit Manipulation (18)
<details>
<summary>8.1 Bit Manipulation (8)</summary>

1. Introduction to Bits
2. Check i-th bit
3. Check odd/even
4. Check power of 2
5. Count set bits
6. Set/Unset rightmost bit
7. Swap numbers
8. Divide integers
</details>

<details>
<summary>8.2 Interview Problems (5)</summary>

1. Count bits to be flipped
2. Find odd occurring number
3. Power Set
4. XOR from L to R
5. Two numbers with odd occurrences
</details>

<details>
<summary>8.3 Advanced Maths (5)</summary>

1. Prime Factors
2. All Divisors
3. Sieve of Eratosthenes
4. Prime Factorisation using Sieve
5. Power(n, x)
</details>

### Step 9: Stack and Queues (30)
<details>
<summary>9.1 Learning (8)</summary>

1. Implement Stack using Arrays
2. Implement Queue using Arrays
3. Implement Stack using Queue
4. Implement Queue using Stack
5. Implement Stack using LinkedList
6. Implement Queue using LinkedList
7. Check Balanced Parentheses
8. Implement Min Stack
</details>

<details>
<summary>9.2 Prefix, Infix, Postfix (6)</summary>

1. Infix to Postfix
2. Prefix to Infix
3. Prefix to Postfix
4. Postfix to Prefix
5. Postfix to Infix
6. Infix to Prefix
</details>

<details>
<summary>9.3 Monotonic Stack/Queue Problems (11)</summary>

1. Next Greater Element
2. Next Greater Element II
3. Next Smaller Element
4. Number of NGEs to the right
5. Trapping Rainwater
6. Sum of Subarray Minimum
7. Asteroid Collision
8. Sum of Subarray Ranges
9. Remove K Digits
10. Largest Rectangle in Histogram
11. Maximal Rectangles
</details>

<details>
<summary>9.4 Implementation Problems (5)</summary>

1. Sliding Window Maximum
2. Stock Span Problem
3. Celebrity Problem
4. LRU Cache
5. LFU Cache
</details>

### Step 10: Sliding Window & Two Pointer (12)
<details>
<summary>10.1 Medium Problems (8)</summary>

1. Longest Substring Without Repeating Characters
2. Max Consecutive Ones III
3. Fruit Into Baskets
4. Longest Repeating Character Replacement
5. Binary Subarray with Sum
6. Count Nice Subarrays
7. Number of Substring Containing All Characters
8. Maximum Points from Cards
</details>

<details>
<summary>10.2 Hard Problems (4)</summary>

1. Longest Substring with K Distinct Characters
2. Subarray with K Different Integers
3. Minimum Window Substring
4. Minimum Window Subsequence
</details>

### Step 11: Heaps (17)
<details>
<summary>11.1 Learning (4)</summary>

1. Introduction to Priority Queues
2. Min/Max Heap Implementation
3. Check if Array is Min-Heap
4. Convert Min to Max Heap
</details>

<details>
<summary>11.2 Medium Problems (7)</summary>

1. Kth Largest Element
2. Kth Smallest Element
3. Sort K Sorted Array
4. Merge M Sorted Lists
5. Replace Elements by Rank
6. Task Scheduler
7. Hands of Straights
</details>

<details>
<summary>11.3 Hard Problems (6)</summary>

1. Design Twitter
2. Connect N Ropes
3. Kth Largest in Stream
4. Maximum Sum Combination
5. Find Median from Data Stream
6. K Most Frequent Elements
</details>

### Step 12: Greedy Algorithms (16)
<details>
<summary>12.1 Easy Problems (5)</summary>

1. Assign Cookies
2. Fractional Knapsack
3. Minimum Coins
4. Lemonade Change
5. Valid Parenthesis
</details>

<details>
<summary>12.2 Medium/Hard Problems (11)</summary>

1. N Meetings in One Room
2. Jump Game
3. Jump Game II
4. Minimum Platforms
5. Job Sequencing
6. Candy Distribution
7. Shortest Job First
8. LRU Page Replacement
9. Insert Interval
10. Merge Intervals
11. Non-overlapping Intervals
</details>

### Step 13: Binary Trees (39)
<details>
<summary>13.1 Traversals (13)</summary>

1. Introduction to Trees
2. Binary Tree in C++
3. Binary Tree in Java
4. Tree Traversals
5. Preorder Traversal
6. Inorder Traversal
7. Postorder Traversal
8. Level Order Traversal
9. Iterative Preorder
10. Iterative Inorder
11. Postorder using 2 Stacks
12. Postorder using 1 Stack
13. All Traversals in One Go
</details>

<details>
<summary>13.2 Medium Problems (12)</summary>

1. Height of Binary Tree
2. Check Balanced Tree
3. Diameter of Tree
4. Maximum Path Sum
5. Check Identical Trees
6. Zigzag Traversal
7. Boundary Traversal
8. Vertical Order Traversal
9. Top View
10. Bottom View
11. Right/Left View
12. Symmetric Tree
</details>

<details>
<summary>13.3 Hard Problems (14)</summary>

1. Root to Node Path
2. LCA in Binary Tree
3. Maximum Width
4. Children Sum Property
5. Nodes at Distance K
6. Burn Binary Tree
7. Count Total Nodes
8. Requirements for Unique Tree
9. Construct from Inorder/Preorder
10. Construct from Postorder/Inorder
11. Serialize and Deserialize
12. Morris Preorder
13. Morris Inorder
14. Flatten to LinkedList
</details>

### Step 14: Binary Search Trees (16)
<details>
<summary>14.1 Concepts (3)</summary>

1. Introduction to BST
2. Search in BST
3. Find Min/Max in BST
</details>

<details>
<summary>14.2 Practice Problems (13)</summary>

1. Ceil in BST
2. Floor in BST
3. Insert Node in BST
4. Delete Node in BST
5. K-th Smallest/Largest in BST
6. Check if Tree is BST
7. LCA in BST
8. Construct BST from Preorder
9. Inorder Successor/Predecessor
10. Merge 2 BSTs
11. Two Sum in BST
12. Recover BST
13. Largest BST in Binary Tree
</details>

### Step 15: Graphs (54)
<details>
<summary>15.1 Learning (6)</summary>

1. Graph and Types
2. Graph Representation C++
3. Graph Representation Java
4. Connected Components
5. BFS
6. DFS
</details>

<details>
<summary>15.2 Problems on BFS/DFS (14)</summary>

1. Number of Provinces
2. Connected Components in Matrix
3. Rotten Oranges
4. Flood Fill
5. Cycle Detection (BFS)
6. Cycle Detection (DFS)
7. 0/1 Matrix
8. Surrounded Regions
9. Number of Enclaves
10. Word Ladder I
11. Word Ladder II
12. Number of Distinct Islands
13. Bipartite Graph
14. Cycle Detection in Directed Graph
</details>

<details>
<summary>15.3 Topo Sort and Problems (7)</summary>

1. Topological Sort
2. Kahn's Algorithm
3. Cycle Detection (BFS)
4. Course Schedule I
5. Course Schedule II
6. Find Eventual Safe States
7. Alien Dictionary
</details>

<details>
<summary>15.4 Shortest Path Algorithms (13)</summary>

1. Shortest Path in Unweighted Graph
2. Shortest Path in DAG
3. Dijkstra's Algorithm
4. Why Priority Queue in Dijkstra
5. Shortest Path in Binary Maze
6. Path with Minimum Effort
7. Cheapest Flights within K Stops
8. Network Delay Time
9. Number of Ways to Destination
10. Minimum Steps to End
11. Bellman Ford Algorithm
12. Floyd Warshall Algorithm
13. City With Smallest Neighbors
</details>

<details>
<summary>15.5 MST/Disjoint Set (11)</summary>

1. Minimum Spanning Tree
2. Prim's Algorithm
3. Disjoint Set (Union by Rank)
4. Disjoint Set (Union by Size)
5. Kruskal's Algorithm
6. Number of Operations for Network
7. Most Stones Removed
8. Accounts Merge
9. Number of Islands II
10. Making Large Island
11. Swim in Rising Water
</details>

<details>
<summary>15.6 Other Algorithms (3)</summary>

1. Bridges in Graph
2. Articulation Point
3. Kosaraju's Algorithm
</details>

### Step 16: Dynamic Programming (56)
<details>
<summary>16.1 Introduction (1)</summary>

1. Dynamic Programming Introduction
</details>

<details>
<summary>16.2 1D DP (5)</summary>

1. Climbing Stairs
2. Frog Jump
3. Frog Jump with K Distance
4. Maximum Sum of Non-Adjacent Elements
5. House Robber
</details>

<details>
<summary>16.3 2D/3D DP and DP on Grids (7)</summary>

1. Ninja's Training
2. Grid Unique Paths
3. Grid Unique Paths 2
4. Minimum Path Sum in Grid
5. Minimum Path Sum in Triangle
6. Maximum Falling Path Sum
7. 3D DP - Ninja and Friends
</details>

<details>
<summary>16.4 DP on Subsequences (11)</summary>

1. Subset Sum Equal to Target
2. Partition Equal Subset Sum
3. Partition Set Into 2 Subsets
4. Count Subsets with Sum K
5. Count Partitions with Difference
6. Assign Cookies
7. Minimum Coins
8. Target Sum
9. Coin Change 2
10. Unbounded Knapsack
11. Rod Cutting Problem
</details>

<details>
<summary>16.5 DP on Strings (10)</summary>

1. Longest Common Subsequence
2. Print LCS
3. Longest Common Substring
4. Longest Palindromic Subsequence
5. Minimum Insertions for Palindrome
6. Minimum Insertions/Deletions
7. Shortest Common Supersequence
8. Distinct Subsequences
9. Edit Distance
10. Wildcard Matching
</details>

<details>
<summary>16.6 DP on Stocks (6)</summary>

1. Best Time to Buy and Sell Stock
2. Buy and Sell Stock II
3. Buy and Sell Stock III
4. Buy and Sell Stock IV
5. Buy and Sell with Cooldown
6. Buy and Sell with Transaction Fee
</details>

<details>
<summary>16.7 DP on LIS (7)</summary>

1. Longest Increasing Subsequence
2. Print LIS
3. Longest Increasing Subsequence Binary Search
4. Largest Divisible Subset
5. Longest String Chain
6. Longest Bitonic Subsequence
7. Number of LIS
</details>

<details>
<summary>16.8 MCM DP (7)</summary>

1. Matrix Chain Multiplication
2. MCM Bottom-Up
3. Minimum Cost to Cut Stick
4. Burst Balloons
5. Evaluate Boolean Expression
6. Palindrome Partitioning II
7. Partition Array for Maximum Sum
</details>

<details>
<summary>16.9 DP on Squares (2)</summary>

1. Maximum Rectangle Area
2. Count Square Submatrices
</details>

### Step 17: Tries (7)
<details>
<summary>17.1 Theory (1)</summary>

1. Implement TRIE
</details>

<details>
<summary>17.2 Problems (6)</summary>

1. Implement Trie II
2. Longest String with All Prefixes
3. Number of Distinct Substrings
4. Bit Prerequisites
5. Maximum XOR of Two Numbers
6. Maximum XOR With Element
</details>

### Step 18: Strings Advanced (9)
<details>
<summary>18.1 Hard Problems (9)</summary>

1. Minimum Bracket Reversals
2. Count and Say
3. Hashing in Strings
4. Rabin Karp
5. Z-Function
6. KMP Algorithm
7. Shortest Palindrome
8. Longest Happy Prefix
9. Count Palindromic Subsequences
</details>

## Contributing
Feel free to contribute to this repository by:
- Reporting issues
- Suggesting improvements
- Adding solutions in different languages
- Improving documentation

## License
This project is available for free use and learning purposes.
